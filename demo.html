<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Project by BovInspectorTool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">BovInspector Demo</h1>
      <a href="https://youtu.be/IMdcksROJDg" class="btn">View on YouTube</a>

    </section>

    <section class="main-content">

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="sample" class="anchor" href="#sample" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Case: Piece of source code of gzip-1.2.4</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="k">167   #define MAX_PATH_LEN 1024</span>
<span class="k">233   char ifname[MAX_PATH_LEN];</span>
<span class="k">997   local int get_istat(iname, sbuf)</span>
<span class="k">998   char *iname;</span>
<span class="k">999   struct stat *sbuf;</span>
<span class="k">1000  {</span>
<span class="k">1001    int ilen;</span>
<span class="k">1002    static char *suffixes[] = {z_suffix, ".gz", ".z", "-z", ".Z", NULL};</span>
<span class="k">1003    char **suf = suffixes;</span>
<span class="k">1004  	char *s;</span>
<span class="k">1005    #ifdef NO_MULTIPLE_DOTS</span>
<span class="k">1006    char *dot;</span>
<span class="k">1007    #endif</span>

<span class="k">1009    strcpy(ifname, iname);</span>
<span class="k">      ...</span>
<span class="k">1066  }</span>
</code></pre></div>
<h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Get Buffer Overflow Warnings</h3>
<p>First, we use Fortify to scan the source code of gizp. Then, we use <code>./fvdlParser audit.fvdl</code> extract the results of Fortify to get static buffer overflow warnings. 
We save these warnings in the file checklist_bufferoverflow. In this sample, checklist_bufferoverflow includes the following segments:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">0</span>
<span class="k">gzip.c	426	DEF</span>
<span class="k">gzip.c	593	N/A</span>
<span class="k">gzip.c	716	N/A</span>
<span class="k">gzip.c	233	N/A</span>
<span class="k">gzip.c	1009	BOF</span>
<span class="k">END_PATH</span>
</code></pre></div>
<p>We can see that there is a static buffer overflow warning at line 1009. DEF is the statement label that
a buffer is first declared or the entry of program. BOF is he statement label that overflow occurs on the buffer.</p>
<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Compile source code to LLVM bitcode</h3>

 KLEE is built on top of LLVM. The first steps are to get a working LLVM installation.You may install llvm-gcc and build LLVM 2.9. 
 To run a program with KLEE, you first compile it to LLVM bitcode using llvm-gcc to generate the LLVM bitcode file xx.bc. 
 You may run <code>   &nbsp llvm-gcc --emit-llvm -c -g src.c</code>.
 For gzip program, we need to modify the makefile to compile the program with llvm-gcc. The correspongding commands are given in 
 <a  href="https://github.com/BovInspectorTool/project/blob/master/testcases/UsefulComands.rar">UsefulComands</a>
 <br>
 Change makefile:
 <br>
<code>  CC = llvm-gcc #for bovinspector</code>
<br>
<code>  LD = llvm-ld  #for bovinspector</code>
<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Perform Warning Reachability Analysis</h3>

<p>Pass framework is a very important part of the LLVM system. Each pass is used to do optimization and conversion work in LLVM. 
buildCFG.so is a shared object complied by LLVM pass we relized and we use it to build CFG, analyse reachablity in the graph and get warning path set.

We use opt to dynamic load shared object buildCFG.so and following command to generate GuideSrc.txt.<br>

<code> &nbsp opt –load ./buildCFG.so –buildCFG –targetList=./checklist_bufferoverflow &lt;xx.bc&gt;/dev/null </code><br>

GuideSrc.txt consists of several warning path set. Each warning path set consists of a set of path segments from program's entry
to the buffer overflow warning point. In this sample, the GuideSrc.txt includes the following segments:<br>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="k">Info:</span>
<span class="k">gzip.c	1695</span>
<span class="k">gzip.c	1686</span>
<span class="k">gzip.c	1684</span>
<span class="k">gzip.c	1679</span>
<span class="k">gzip.c	712</span>
<span class="k">gzip.c	1639</span>
<span class="k">...</span>
</code></pre></div>
More information can be fetched from  <a  href="https://github.com/BovInspectorTool/project/blob/master/testcases/gzip-1.2.4/GuideSrc.txt">GuideSrc.txt</a>.
During the process of symbolic execution,  GuideSrc.txt will be read in and the path set in the text will be validated.
<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Perform Guided Symbolic Execution and Buffer Overflow Validation</h3>

To use klee to perform guided symbolic execution and buffer overflow validation, you need to run klee with command line option --guided-execution and additional input file GuideSrc.txt which should be copyed the to directory where the source file is.<br>
<code> &nbsp klee --libc=uclibc --posix-runtime --guided-execution ./gzip.bc --sym-args 1 3 1025 --sym-files 2 2</code><br>
 BovInspector reports line 1009 is a true warning and saves the results in file report_BFO.txt. And false warnings will be saved in report_NOTBFO.txt.
<br>
<p>In file report_BFO.txt:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">gzip.c_1009 strcpy</code></pre></div>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Perform Targeted Automatic Repair</h3>

<p>Use python repair.py to repair the vulnerabilities that have been validated.</p>
<br>
Repair Mode: add boundary checks
<br>
Command: 
<code>python repair.py</code>
<p>Repair Result：</p><br>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="k">1009  if(strlen(iname) >= sizeof(ifname)){</span>
<span class="k">1010  	printf("strcpy may have a buffer overflow, we just exit\n");</span>
<span class="k">1011	return 0;</span>
<span class="k">1012  }</span>
<span class="k">1013  strcpy(ifname, iname);</span>
</code></pre></div>
<br>
Repair Mode: API-Replacement
<br>
Command: 
<code>python repair.py --mode=API-REP</code>
<br>
<p>Repair Result：</p><br>
<div class="highlight"><pre><code class="language-c" data-lang="c">
1009  strncpy(ifname,iname,sizeof(ifname));
</code></pre></div>
<p>After repair, the repaired source code will be rescanned by Fortify. 
The results show that Fortify reports no buffer overflow on the new line.</p>
</section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Demo maintained by <a href="https://github.com/BovInspector">BovInspector</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
